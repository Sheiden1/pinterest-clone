<<<<<<< HEAD
from __future__ import annotations

import typing as t
=======
import typing as _t
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
import zlib

from ._json import _CompactJSON
from .encoding import base64_decode
from .encoding import base64_encode
from .exc import BadPayload
<<<<<<< HEAD
from .serializer import _PDataSerializer
=======
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
from .serializer import Serializer
from .timed import TimedSerializer


<<<<<<< HEAD
class URLSafeSerializerMixin(Serializer[str]):
=======
class URLSafeSerializerMixin(Serializer):
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
    """Mixed in with a regular serializer it will attempt to zlib
    compress the string to make it shorter if necessary. It will also
    base64 encode the string so that it can safely be placed in a URL.
    """

<<<<<<< HEAD
    default_serializer: _PDataSerializer[str] = _CompactJSON
=======
    default_serializer = _CompactJSON
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e

    def load_payload(
        self,
        payload: bytes,
<<<<<<< HEAD
        *args: t.Any,
        serializer: t.Any | None = None,
        **kwargs: t.Any,
    ) -> t.Any:
=======
        *args: _t.Any,
        serializer: _t.Optional[_t.Any] = None,
        **kwargs: _t.Any,
    ) -> _t.Any:
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
        decompress = False

        if payload.startswith(b"."):
            payload = payload[1:]
            decompress = True

        try:
            json = base64_decode(payload)
        except Exception as e:
            raise BadPayload(
                "Could not base64 decode the payload because of an exception",
                original_error=e,
            ) from e

        if decompress:
            try:
                json = zlib.decompress(json)
            except Exception as e:
                raise BadPayload(
                    "Could not zlib decompress the payload before decoding the payload",
                    original_error=e,
                ) from e

        return super().load_payload(json, *args, **kwargs)

<<<<<<< HEAD
    def dump_payload(self, obj: t.Any) -> bytes:
=======
    def dump_payload(self, obj: _t.Any) -> bytes:
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
        json = super().dump_payload(obj)
        is_compressed = False
        compressed = zlib.compress(json)

        if len(compressed) < (len(json) - 1):
            json = compressed
            is_compressed = True

        base64d = base64_encode(json)

        if is_compressed:
            base64d = b"." + base64d

        return base64d


<<<<<<< HEAD
class URLSafeSerializer(URLSafeSerializerMixin, Serializer[str]):
=======
class URLSafeSerializer(URLSafeSerializerMixin, Serializer):
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
    """Works like :class:`.Serializer` but dumps and loads into a URL
    safe string consisting of the upper and lowercase character of the
    alphabet as well as ``'_'``, ``'-'`` and ``'.'``.
    """


<<<<<<< HEAD
class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer[str]):
=======
class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer):
>>>>>>> 62bfd5b289aff96e9a36f9e6578d89e41d91673e
    """Works like :class:`.TimedSerializer` but dumps and loads into a
    URL safe string consisting of the upper and lowercase character of
    the alphabet as well as ``'_'``, ``'-'`` and ``'.'``.
    """
